#!/usr/bin/env ruby

require 'daemons'
require 'eventmachine'
require 'logger'
require 'yaml'
require 'tweetlr'

begin
  config_file = File.join( Dir.pwd,  'config', 'tweetlr.yml')
  tid_file = File.join( Dir.pwd ,"tweetlr.tid")
  start_at_tweet_id = lambda { 
     begin
      File.open(tid_file, "r") { |io| io.gets.to_i } 
    	rescue Errno::ENOENT => e
        $stderr.puts "#{e} - we use the value from the configuration file" 
    	  nil 
    	end
  }.call
  CONFIG = YAML.load_file(config_file)
  CONFIG['start_at_tweet_id'] = start_at_tweet_id || CONFIG['start_at_tweet_id'] || CONFIG['twitter_timestamp'] #check the latter for backwards compability
   
  UPDATE_PERIOD = CONFIG['update_period']  
  
  @tweetlr = Tweetlr.new(CONFIG['tumblr_username'], CONFIG['tumblr_password'], {
    :whitelist => CONFIG['whitelist'], 
    :shouts => CONFIG['shouts'], 
    :since_id => CONFIG['start_at_tweet_id'] , 
    :terms => CONFIG['search_term'], 
    :loglevel => CONFIG['loglevel'],
    :update_period => UPDATE_PERIOD,
    :api_endpoint_tumblr => CONFIG['api_endpoint_tumblr'],
    :api_endpoint_twitter => CONFIG['api_endpoint_twitter'],
    :results_per_page => CONFIG['results_per_page'],
    :result_type => CONFIG['result_type']
    })
rescue SystemCallError
  $stderr.puts "Ooops - looks like there is no ./config/tweetlr.yml found. I'm affraid tweetlr won't work properly until you introduced that configuration file."
  exit(1)
end

Daemons.run_proc('tweetlr', :dir_mode => :script, :dir => './', :backtrace => true, :log_output => true) do
  @log = Logger.new(STDOUT)
  @log.info "starting tweetlr daemon..." 
  @log.info "creating a new tweetlr instance using this config: #{CONFIG.inspect}"   
  EventMachine::run { 
    EventMachine::add_periodic_timer( UPDATE_PERIOD ) {
     @log.info "starting tweetlr crawl..."
     response = {}
     response = @tweetlr.lazy_search_twitter(@tweetlr.twitter_config["refresh_url"]) #looks awkward, but the refresh url will come from the db soon and make sense then...
     if response
       tweets = response['results']
       if tweets
       tweets.each do |tweet|
         tumblr_post = @tweetlr.generate_tumblr_photo_post tweet
         if tumblr_post.nil? ||  tumblr_post[:source].nil?
            @log.warn "could not get image source: tweet: #{tweet} --- tumblr post: #{tumblr_post.inspect}"
         else
           @log.debug "tumblr post: #{tumblr_post}"
           res = @tweetlr.post_to_tumblr tumblr_post
           @log.warn "tumblr response: #{res.header_str} #{res.body_str}" unless res.response_code == 201
         end
        end
         # store the highest tweet id
         @tweetlr.twitter_config[:refresh_url]=response['refresh_url']
         File.open(tid_file, "w+") { |io| io.write(response['max_id']) }
       end
     else
       @log.error "twitter search returned no response. hail the failwhale!"
     end
     @log.info "finished tweetlr crawl."
     }
   }
end